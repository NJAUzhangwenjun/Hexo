---
title: '常见算法'
date: 2019-11-24 18:17:01
category: 
    - 算法
author: 张文军
tags: 
    - '常见算法'
top: false
# img: https://upload-images.jianshu.io/upload_images/2291135-f88efeec448e959e?imageMogr2/auto-orient/strip|imageView2/2/w/463/format/webp
cover: true
summary: 常见算法的简单实现
---

<center>更多内容请关注：</center>

![Java快速开发学习](https://zhangwenjun-1258908231.cos.ap-nanjing.myqcloud.com/njauit/1586869254.png)

<center><a href="https://wjhub.gitee.io">锁清秋</a></center>

----
# 常见算法




## 概要

- 简单说，算法就是计算机解题的过程
- 五个特征：输入，输出，可行性，有穷性，准确性

- 时间复杂度


- 非线性表

- 查找

- 线性表查找

- 顺序查找
- 折半查找

- 递归 

- 查找树

- 分类：NVL、红黑树，B树，B+树、B*树

- 哈希表

- 排序

- 比较排序

- 插入排序

	- 直接插入排序
	- 希尔排序
	- 折半插入排序

- 选择排序

	- 选择排序
	- 堆排序

- 交换排序

	- 冒号排序
	- 快速排序

		- 特点：冒泡、分区、递归；东拆西补，西拆东补西，一边拆，一边补

- 归并排序

  - 归并排序
- 非比较排序

- 计算排序
- 基数排序
  
---
---
## 递归

### 简述

> 简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

### 递归需要遵守的重要规则

- 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
- 方法的局部变量是独立的，不会相互影响, 比如n变量
- 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
- 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了,哈哈哈)
- 当一个方法执行完毕，或者遇到return，就会返回，遵守**谁调用，就将结果返回给谁**，同时当方法执行完毕或者返回时，该方法也就执行完毕。
  
### 简单示例

#### 斐波那契数列
> F[n] = F[n-1] + F[n-2]   (n>=3,F[1]=1,F[2]=1)

```java
public class Solution {
    public int Fibonacci(int n) {
        if(n ==0){
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        } else {
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }     
    }
}
```

## 算法的时间复杂度

### 简单概述

- 时间频度：

  >一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

- 时间复杂度：
  > - 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当**n趋近于无穷大时**，**T(n) / f(n) 的极限值为不等于零的常数**，**则称f(n)是T(n)的同数量级函数**。记作 **T(n)=Ｏ( f(n) )**，称**Ｏ( f(n) )**  为算法的渐进时间复杂度，简称**时间复杂度**
  >
  > - T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)
  >

- 计算时间复杂度的方法
  > - 1、 用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  => T(n)=n²+7n+1
  >
  > - 2、修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 => T(n) = n²
  >
  > - 3、去除最高阶项的系数 T(n) = n² => T(n) = n² => O(n²)

### 常见的时间复杂度

1. 常数阶O(1)
2. 对数阶O(log2n)
3. 线性阶O(n)
4. 线性对数阶O(nlog2n)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

  ![d](/images/图片6.png)

 说明：
 > 常见的算法时间复杂度由小到大依次为：Ο(1) ＜ Ο(log2n) ＜ Ο(n)＜ Ο(nlog2n) ＜ Ο(n2) ＜ Ο(n3) ＜ Ο(nk) ＜Ο(n²) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
 > 我们应该尽可能避免使用指数阶的算法

### 平均时间复杂度和最坏时间复杂度

> 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。
>
> 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。
>
>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)
  ![tt](/images/图片7.png)

## 算法的空间复杂度

   1. 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
   2. 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
   3. 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

## [常见排序算法](http://www.njauwen.xyz/object-object-chang-jian-pai-xu-suan-fa/)

## [常见查找算法](http://www.njauwen.xyz/object-object-chang-jian-cha-zhao-suan-fa/)
